# 비밀번호 암호화

이 문서에서는 비밀번호를 암호화해야 하는 이유와 방법을 다룹니다.

먼저 '암호화'란,
'**통신의 원문을 일정한 암호 시스템에 따라 암호문으로 바꾸는 일**'로
정의됩니다.
쉽게 말해, 중요한 정보를 감추기 위해 설계된 알고리즘에 의해
정보를 알아보기 힘들게 가공하는 일을 뜻합니다.
암호화된 정보를 **암호문**이라고 하며,
암호화 전의 원래 정보를 **평문**이라고 합니다.
평문을 암호문으로 바꾸는 작업을 **암호화**라고 한다면,
반대로 암호문을 평문으로 바꾸는 작업은
**복호화**(또는 해독, decryption)라고 합니다.

2019년 3월, 페이스북은 약 6억 개의 **암호화되지 않은** 비밀번호를
노출한 대형 보안 사고를 일으켰습니다.
이 사고에는 크게 두 가지 문제가 존재했습니다.
첫 번째는 비밀번호가 유출되었다는 것이며 두 번째는 그 비밀번호가 암호화되지
않은 채로 페이스북 서버에 저장되어 있었다는 사실입니다.
페이스북과 같은 멀티 유저 서비스는 주로 아이디와 비밀번호를 통해
개인을 식별합니다.
이러한 비밀번호의 사용자는 여러 다른 서비스에서도 같은 비밀번호를
사용하고 있을 확률이 높습니다.
따라서 그중 하나의 서버에서 비밀번호가 유출된다면
해당 비밀번호를 사용하던 모든 서비스의 계정의 보안 위협을 받습니다.
때문에 개발자는 비밀번호를 암호화하여 저장하도록 하고 있습니다.
하지만 서버는 사용자가 로그인하기 위해 입력한 비밀번호와
이미 서버에 저장되어 있는 비밀번호를 대조하여 비밀번호의 일치 여부를 확인해야 합니다.
이런 상황에 좋은 암호화 알고리즘은 무엇일까요?

대한민국의 개인정보 보호법에 의한
[개인정보의 안전성 확보조치 기준 제 7조의 2](<http://www.law.go.kr/행정규칙/개인정보의안전성확보조치기준/(2019-47,20190607)/제7조>)에
의하면, 비밀번호의 경우는 **일방향 암호화**하여 저장 해야 합니다.
일방향 암호화(또는 단방향 암호화)란,
암호화는 가능하지만 복호화는 불가능한(또는 불가능에 가까운) 암호화 방식입니다.
단방향 암호화의 대표적인 방식으로는 '해시 함수'가 있습니다.

해시 함수는 여러 알고리즘을 가지고 있습니다.
이 글에서는 `bcrypt`라는 알고리즘을 사용합니다.
`bcrypt` 알고리즘의 해시 함수를 통해 `12345`라는 비밀번호를 암호화하면
다음과 같이 원문과 아무런 관련없는 암호문을 만들어냅니다.

> `$2b$10$/g3pPbkShhr5h558UVQlmO3z2AEvzh0RWTJKqiBdquFE.v55MV9xG`

우리는 이렇게 암호화된 암호문을 원문 대신 저장해야 합니다.
이를 통해 개발자나 해커가 위와 같은 암호문을 통해 원문, 즉 비밀번호가
무엇인지 예측할 수 없게 되기 때문입니다.
하지만 동일한 사용자가 로그인을 위해 `12345`를 입력한다면
해시 함수는 다시 위와 같은 값을 결과로 낼 것이며,
이 값과 미리 저장된 값을 대조하였을 때 두 값은 일치하므로 원문인 `12345`도 동일하다는
것을 유추할 수 있습니다.

이러한 해시 함수에는 다음과 같은 특성이 있습니다.
(다음과 같은 특성으로 보안 효과를 누릴 수 있다는 이론적 설명이며,
필요하지 않다면 넘어가도 좋습니다.)

<details>
<summary>해시 함수의 특성</summary>

입력값 x와 해시함수값 y에 대하여, 다음과 같은 특성을 갖습니다.

### **결정론적**

> 결정론적 알고리즘(deterministic algorithm)은 예측한 그대로 동작하는 알고리즘이다.
>
> \- Wikipedia

입력 x에 대하며 출력 y가 항상 동일하다는 뜻입니다.

### **단방향성 (또는 역상 저항성, 역상에 대한 안정성)**

y만 확인할 수 있는 상황에서 입력값 x를 찾는 것이 계산적으로 불가능합니다.
쉽게 말해, 해시함수를 통해 암호화된 암호문만으로는
원문을 찾는 것이 계산적으로 불가능하다는 것을 뜻합니다.
만약 저장된 값인 y가 유출되거나 개발자가 나쁜 의도를 갖고 접근해도
사용자의 실제 비밀번호를 알 수 없도록 합니다.
무차별 대입 공격은 거의 모든 암호화 방식의 취약점으로 알려져 있지만
소모되는 비용이나 시간이 너무 커서 실용적이지 못한 공격 방법입니다.

### **제 2 역상 저항성(또는 제2 역상에 대한 안정성)**

동일한 해시함수값 y를 내는 다른 입력값 x'을 찾는 것이 계산적으로 불가능합니다.
위에서 언급한 입력값 `12345`에 대한 해쉬값을 `12345`가 아닌 입력값에서
출력값으로 나올 것을 찾을 수 없다는 것 입니다.
이를 통해 사용자가 틀린 비밀번호를 입력하면 다른 해시값이 나올 것이며
이 값이 저장된 값이 다르므로 비밀번호가 틀렸음을 유추해낼 수 있습니다.

### **충돌 저항성(또는 충돌에 대한 안정성)**

동일한 해시함수값 y를 갖는 서로 다른 x와 x'를 찾는 것이
계산적으로 불가능합니다. 이는 위의 제 2 역상 저항성의
부수효과이며 부분집합입니다.

### **눈사태 효과(또는 산사태효과, 쇄도 효과)**

> 쇄도 효과(avalanche effect), 산사태 효과는 어떤 암호 알고리즘이
> 입력값에 미세한 변화를 줄 경우 출력값에 상당한 변화가 일어나는 성질을 의미한다.
>
> \- Wikipedia

예를 들어 입력값 x에 문자 `'A'`를 추가하는 것과 같은 작은 변화로도
결과 y는 이전과 전혀 다르게 나오는 것을 의미합니다.
실제로 `12345`와 `12345A`의 해시 함수값은 아래와 같이 크게 다르며
어떠한 규칙성도 찾을 수 없습니다.

| x      | y                                                             |
| ------ | ------------------------------------------------------------- |
| 12345  | $2b$10\$/g3pPbkShhr5h558UVQlmO3z2AEvzh0RWTJKqiBdquFE.v55MV9xG |
| 12345A | $2b$10\$qzqdbfBSKwr/6uGAPl.AYuhCN0g2RZXfyPXBWLxag1kihw7nVKFdG |

<hr />
</details>

하지만 이러한 해시 함수도 **무차별 대입 공격**에는 취약하다는 점을 인지해야합니다.
**무차별 대입 공격**(brute-force attack)이란, 암호로 사용할 수 있는 모든 값을
대입해보는 것을 뜻합니다.
해시 함수 값 y를 만족하는 x를 찾기 위해 비밀번호가 될 수 있는 모든 문자열에 대한
해시 함수 값을 찾아보는 것입니다.

<!-- TODO: 무차별 대입 공격 방어 및 솔트에 대한 글 추가하기 -->

그럼 이제 실무에서 어떻게 코드를 작성해야하는지 배워봅니다.

<details>
<summary>NodsJS 예제</summary>

**!주의!** 이 예제는 비밀번호의 저장을 파일 시스템(fs)를 통해
진행합니다. 실무에서는 여러분의 환경에 맞게 사용해주세요.

우선 bcrypt 알고리즘을 사용하기 위해 bcrypt 모듈을 설치합니다.

```bash
npm i bcrypt
```

예제에서는 콘솔 입력을 통해 비밀번호를 받아옵니다.

```js
// 비밀번호 저장.js
const fs = require('fs');
const bcrypt = require('bcrypt');
const [password] = process.argv.slice(2);
const saltRounds = 10;

if (!password) {
  console.log('비밀번호를 입력하지 않았습니다!!!');
  process.exit(0);
}

bcrypt.hash(password, saltRounds).then((hash) => {
  fs.writeFileSync(__dirname + '/비밀번호', hash);
  console.log('비밀번호가 저장되었습니다.');
});
```

```js
// 로그인.js
const fs = require('fs');
const bcrypt = require('bcrypt');
const [password = ''] = process.argv.slice(2);
const hash = fs.readFileSync(__dirname + '/비밀번호', 'utf8');

bcrypt.compare(password, hash).then((result) => {
  if (result) {
    console.log('로그인하셨습니다.');
  } else {
    console.log('비밀번호가 틀렸네요.');
  }
});
```

</details>

<!--
<details>
<summary>OO언어 예제</summary>
내용
</details>
-->

<!-- 예제를 추가해주세요!! -->

## 참고 자료

- [한국 인터넷 진흥원 개인정보의 암호화 조치 안내서](http://www.kisa.or.kr/uploadfile/201806/201806120949471644.pdf)
- [개인정보의 안전성 확보조치 기준](http://www.law.go.kr/행정규칙/개인정보의안전성확보조치기준)
- [흔들리는 페이스북 보안... 비번 6억개 무방비 노출 확인](http://www.bloter.net/archives/334073)
- [해시함수에 대한 개념 정리하기](https://velog.io/@zuyonze/해시함수에-대한-개념-정리하기)
- [암호화-위키피디아](https://ko.wikipedia.org/wiki/암호화)
- [해시함수-위키피디아](https://ko.wikipedia.org/wiki/해시_함수)
- [쇄도 효과-위키피디아](https://ko.wikipedia.org/wiki/쇄도_효과)
